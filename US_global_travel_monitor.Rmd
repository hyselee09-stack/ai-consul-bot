---
title: "US Global Travel Advisory Monitor (With Memory)"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# 'httr' package is essential for bypassing bot detection
if (!require("pacman")) install.packages("pacman")
pacman::p_load(httr, tidyRSS, tidyverse, telegram.bot, lubridate, stringr, readr, xml2)


# Retrieve secrets from GitHub Environment Variables
TELEGRAM_BOT_TOKEN <- Sys.getenv("TELEGRAM_BOT_TOKEN")
MY_CHAT_ID         <- Sys.getenv("MY_CHAT_ID")
bot <- Bot(token = TELEGRAM_BOT_TOKEN)


# ==============================================================================
# Global Safety Level Monitor (Comparison with Previous Data)
# ==============================================================================
print(paste("üåç [Global Watch]", Sys.time(), "Scanning Travel Advisories..."))

feed_url <- "[http://travel.state.gov/content/travel/en/traveladvisories/traveladvisories/jcr:content/par/feed.rss](http://travel.state.gov/content/travel/en/traveladvisories/traveladvisories/jcr:content/par/feed.rss)"
csv_file <- "travel_status_memory.csv" # File to store history

# [Crucial Function] Safe Fetch to bypass 403 Bot Detection
fetch_feed_safe <- function(url) {
  tryCatch({
    # 1. Pretend to be a browser (User-Agent Spoofing)
    response <- GET(
      url, 
      add_headers("User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
    )
    
    # 2. Check Status Code
    if (status_code(response) != 200) {
      print(paste("‚ö†Ô∏è Connection Failed. Status Code:", status_code(response)))
      return(NULL)
    }
    
    # 3. Parse Content
    content_text <- content(response, "text", encoding = "UTF-8")
    return(tidyRSS::tidyfeed(content_text))
    
  }, error = function(e) {
    print(paste("‚ö†Ô∏è Network Error:", e$message))
    return(NULL)
  })
}

# --- Main Execution Logic ---

# 1. Fetch Data Safely
feed <- fetch_feed_safe(feed_url)

if (!is.null(feed) && nrow(feed) > 0) {
  
  # Clean and Extract Data
  current_data <- feed %>%
    select(item_title, item_link) %>%
    mutate(
      Country = str_trim(str_extract(item_title, "^.*?(?=\\s-\\sLevel)")),
      Level_Num = as.numeric(str_extract(item_title, "(?<=Level\\s)[0-9]")),
      Level_Text = str_trim(str_extract(item_title, "(?<=Level\\s).*"))
    ) %>%
    filter(!is.na(Country) & !is.na(Level_Num)) %>%
    select(Country, Level_Num, Level_Text, item_link)

  # 2. Load Previous Data (If CSV exists)
  if (file.exists(csv_file)) {
    past_data <- read_csv(csv_file, show_col_types = FALSE)
    
    # 3. Compare Logic (Join old and new data)
    comparison <- current_data %>%
      inner_join(past_data, by = "Country", suffix = c("_new", "_old")) %>%
      filter(Level_Num_new != Level_Num_old) # Filter only changed levels
      
    # 4. Detect Changes and Send Alerts
    if (nrow(comparison) > 0) {
      
      for(i in 1:nrow(comparison)) {
        row <- comparison[i, ]
        
        # Determine Direction of Change
        if (row$Level_Num_new > row$Level_Num_old) {
          status_msg <- "üö® Risk Increased (Worsened)"
          emoji <- "üìâ"
        } else {
          status_msg <- "‚úÖ Situation Improved"
          emoji <- "üìà"
        }
        
        # Compose Message (English)
        msg <- paste0(
          "üá∫üá∏ [Travel Advisory Update]\n\n",
          "üè≥Ô∏è Country: ", row$Country, "\n",
          emoji, " Status: ", status_msg, "\n",
          "üî¢ Level Change: Lv.", row$Level_Num_old, " ‚û°Ô∏è Lv.", row$Level_Num_new, "\n",
          "üìù Summary: ", row$Level_Text_new, "\n",
          "üîó Link: ", row$item_link_new
        )
        
        try(bot$sendMessage(chat_id = MY_CHAT_ID, text = msg))
        Sys.sleep(1)
      }
      print(paste("‚úÖ Sent alerts for", nrow(comparison), "changed countries."))
      
    } else {
      print("   -> No changes in safety levels.")
    }
    
  } else {
    print("   -> [Init] No history found. Creating new data file.")
  }
  
  # 5. Save Current Data (Update CSV for next run)
  # Only save if data fetch was successful
  write_csv(current_data, csv_file)
  print(paste("üíæ Current status saved to:", csv_file))

} else {
  print("‚ùå Failed to fetch data. (File not updated)")
}


